# bunner-router-rs: 라우터 비교·분석 보고서

본 문서는 본 프로젝트의 범위를 “라우트 키만 반환하는 초경량 라우팅 엔진(route-key-only matcher)”으로 명확히 한 뒤, 기능/성능/안정성/DX 관점의 강·약점을 정리하고 Rust/Node/Go/Python의 대표 라우터들과 비교합니다. 즉, 핸들러 저장/미들웨어/프레임워크 통합은 명시적으로 스코프 밖입니다.

## 1) 현재 구현 개요
- 자료구조: Radix Tree(압축 라딕스 트리)
  - 정적 경로는 정렬된 키/값 벡터 + 인덱스 미러를 사용
  - 연속 정적 세그먼트는 fused edge로 압축, 깊이 감소
  - 패턴 자식은 SoA 구조와 여러 인덱스(첫 리터럴/첫 바이트)로 스캔 최소화
- 등록/Seal/조회 흐름
  - 등록: `Router::add` / `add_bulk` → `RadixTree::insert(_bulk)` (핸들러 저장 없음, route key만 관리)
  - 최종화(Seal): `Router::seal()` → 트리 압축·인덱싱·Pruning Map·Static Map 생성 → ReadOnly 스냅샷 생성
  - 조회: `Router::find(method, path)`: 정규화 → 정적 맵 O(1) 조회 → 패턴/와일드카드 탐색 → 결과는 항상 `(route_key, params)` 형태
- 동시성
  - 등록 단계는 내부 RwLock으로 보호
  - Seal 후 `RouterReadOnly`는 `Arc`로 공유되고, 조회는 락 없이 수행
  - 파라미터 버퍼는 TLS(thread_local)로 재사용해 할당 최소화
- 에러/진단
  - `RouterErrorCode` + 구조화된 `RouterError(serde 가능)`
  - stage/operation/extra(JSON)로 원인 파악 용이
- 옵션
  - `RouterOptions`: root pruning, static full mapping, 자동 최적화(휴리스틱) 지원

## 2) 기능 측면 진단
현재 지원
- HTTP 메서드: 7개 고정 인덱스 배열 기반
- 경로 정규화: ASCII만 허용, 중복 슬래시 압축, '/../' 금지, 후행 슬래시 트리밍
- 패턴: 세그먼트 단위에서
  - 리터럴
  - 네임드 파라미터 `:name` (문자/숫자/언더스코어, 첫 글자 규칙 포함)
  - 와일드카드 `*` (세그먼트 마지막에서만, 잔여 경로 캡처)
- 정적 경로 O(1) 매핑(옵션)
- 중복/충돌 검증: 같은 노드에서 파라미터명 충돌, 중복 등록 감지

부족/미지원
- 패턴 표현력 제한
  - 정규식/제약(숫자만 등), 선택적 세그먼트, 다중 와일드카드, 매트릭스 파라미터 미지원
  - 와일드카드는 세그먼트 끝에만 허용
- 역방향 라우팅(경로 생성) 부재
- 호스트 기반 라우팅, 버전 라우팅, 컨텍스트별 Prefix/Group 미지원
- Trailing slash 정책(redirect/허용), 대소문자/퍼센트 디코딩 정책 없음
- 의도적 비포함: 라우트 메타데이터/핸들러 저장은 스코프 밖(설계 상위 레이어 책임)
- Querystring, 헤더/콘텐츠-네고 등과의 통합 없음

## 3) 성능 설계 요인 분석
강점(설계상 이점)
- 정적 경로: 정적 전체맵 활성 시 O(1) 키 조회
- 루트 수준 pruning 비트맵/길이 버킷으로 불필요 분기 감소
- Fused edge로 깊이 축소 → 캐시 지역성 개선
- 패턴 인덱스(첫 리터럴/첫 바이트/param-first)로 스캔 최소화
- SmallVec/hashbrown/parking_lot/bumpalo 등으로 힙/락 비용 최소화
- Bulk insert: 병렬 파싱 + interner 예열 + preassigned key로 locality 향상
- TLS 파라미터 버퍼로 할당 제거

잠재 병목/개선 포인트(스코프 내)
- 정규화 단계가 ASCII 강제 및 문자열 치환(replace) 수행 → 퍼센트 디코딩/유니코드 지원 시 비용 증가 가능
- 패턴 표현력 확장 시(정규식/옵셔널) 검색 비용 증가 우려 → 세그먼트별 상태기계/dfa-like 인덱스 필요
- Static map의 메모리 사용량: 라우트 수가 많을 때 `maps[method]`의 메모리 footprint 증가
- Seal 필수의 이원화 모델: 실시간 라우트 변경(use cases: hot reload)에는 부적합(단, key-only 엔진 특성상 재빌드 비용을 상위 레이어 캐싱으로 상쇄 가능)

## 4) 안정성/메모리/동시성
- 안전성: `NodeBox(NonNull)` + bump allocator를 래핑하여 안전 API 노출(직접 unsafe 사용은 모듈 내부 한정)
- 메모리: finalize 시 shrink/warmup 수행, interner 역테이블 cleanup
- 동시성: ReadOnly 스냅샷으로 조회 경합 제거, `OnceLock`으로 단 한 번 설정 보장
- 리스크
  - 테스트/예제 부재 → 회귀/엣지 케이스 방어 미흡
  - Seal 전/후 상태 전이가 명확하지만, 실수로 `find`를 Seal 전에 호출하면 `NotSealed` 에러 → DX 관점 가드 필요
  - Seal 이후 `RadixTree`를 새로 생성해 옵션이 초기화됨(오류 가능성) → 옵션 유지/전달 방식 보완 필요

## 5) DX(개발자 경험)
장점
- 에러 구조화, 추적 가능한 stage/operation, `serde` 직렬화 가능
- 간단한 API(등록→seal→find)와 선택적 옵션

부족/개선 필요(스코프 내)
- 문서/예제/테스트/README 없음 → 진입 장벽 높음
- 파라미터 결과가 (offset, length)로만 제공 → 문자열 추출 유틸/iterator 제공 시 DX 개선
- 트레이싱/로그 기본 레벨/필드 정책 안내 미흡

## 6) 타 라우터와의 비교
아래 비교는 공개적으로 알려진 구조/특징 기반의 일반적 경향 비교입니다. 각 프로젝트의 버전/구성에 따라 차이가 있을 수 있습니다.

### Rust 생태계(핵심 비교 축: “키만 반환하는 매칭 엔진”)
- axum (matchit 기반)
  - 기능: 풍부한 핸들러 타입 시스템, 미들웨어(tower), 추출기, 상태 관리, 에러 핸들링 체계
  - 성능: matchit의 트리 + 내부 최적화, 대규모 프로덕션 검증
  - DX: 라우팅과 핸들러/미들웨어를 통합 제공, 문서와 사례 풍부
  - 대비: bunner-router-rs는 “키만 반환” 설계로 범위가 더 좁음. matchit과 유사한 코어 목표이지만, 정적 맵 O(1), 루트 pruning, fused edge 등 일부 최적화가 차별점
- actix-web
  - 기능: 스코프/리소스/가드, 추출기, 미들웨어, 고성능 런타임
  - 성능: 고성능 프레임워크로 알려짐(내부 라우팅도 최적화), 넓은 실전 사례
  - DX: 선언적 라우팅/가드체계. 생태계 도구 풍부
  - 대비: 본 프로젝트는 프레임워크 기능을 의도적으로 비포함. 순수 키 매칭 엔진으로는 더 가볍고 임베드 용이
- warp
  - 기능: 필터 조합 기반의 타입 안전 라우팅, 강한 컴파일타임 보장
  - 성능: 필터 체인 비용 존재하나 충분히 빠름
  - DX: 러스트스러운 함수 합성. 러닝 커브는 있으나 문서 풍부
  - 대비: 본 프로젝트는 타입 합성이 아닌 “고속 키 매칭”을 목표로 하므로 비교축이 다름(스코프 밖)
- matchit / route-recognizer (라우팅 코어 크레이트)
  - 기능: 표현력은 제한적이나 경량/고성능 route match 제공
  - 성능: 최적화된 트리, 광범위 사용 사례
  - 대비: bunner는 정적 O(1) 맵/루트 pruning/fused edge 등 최적화를 공격적으로 적용한 key-only 엔진. 다만 API 안정성/테스트/문서 측면은 아직 보강 필요

### Node.js (엔진 대비)
- find-my-way (Fastify Router)
  - 기능: radix tree, 네임드 파라미터, 와일드카드, constraints(Host, Version), store/handler 보관, 405/501 처리 등
  - 성능: 매우 빠른 편으로 알려짐, 대규모 사용처
  - DX: Fastify와의 자연스러운 통합, 플러그인 생태계
  - 대비: bunner는 오직 키 매칭에만 집중. constraints/핸들러 저장은 스코프 밖이므로 직접 비교 대상에서 제외. 트리/인덱싱 최적화 철학은 유사
- Express (path-to-regexp)
  - 기능: 풍부한 패턴(옵셔널, 반복, 정규식), 미들웨어 체인, 생태계 압도적
  - 성능: find-my-way 대비 다소 느림(표현력 대가)
  - 대비: bunner는 정규식 비용을 제거하고 키 매칭 고속화를 택한 상반된 전략

### Go (엔진 대비)
- httprouter (Radix Tree)
  - 기능: 네임드 파라미터, catch-all, 빠른 라우팅으로 유명, 핸들러 저장 및 파라미터 추출 제공
  - 성능: 라딕스 트리 기반 고성능
  - DX: 단순 API, 안정적
  - 대비: 아이디어 면에서 유사(라딕스 + 와일드카드). bunner는 key-only라 더 단순/경량하며 상위 레이어 조합에 초점
- chi
  - 기능: 미들웨어/그룹/서브라우터/컨텍스트 등 현대적 DX
  - 성능: 충분히 빠름, 실전 사례 많음
  - 대비: 프레임워크 기능이 스코프 밖이므로 직접 비교 대상에서 제외(철학 상 다름)

### Python (Starlette/FastAPI)
- 기능: 경로 파라미터 타입 검증, 종합적인 요청/응답 모델, 문서화 자동화(OpenAPI)
- 성능: ASGI 생태계에서 충분한 성능
- DX: 뛰어난 문서/타입 기반 검증/생태계
- 대비: bunner는 라우팅 엔진에 집중, 타입/검증/문서화는 스코프 밖

## 7) 부족한 점(정리: key-only 스코프)
- 기능
  - 제약/정규식/옵셔널/반복/멀티 와일드카드/그룹/호스트/버전/Prefix 등 확장성 부족
  - (스코프 밖) 라우트 메타데이터/핸들러 저장/미들웨어 결합, 역방향 라우팅/URL 빌더는 의도적 미제공
  - Trailing slash 정책 미노출(redirect/동등 처리 등)
- 성능/설계
  - 정규화 정책(ASCII 고정)은 다국어/퍼센트 디코딩 요구에서 제약이 큼
  - Static full map/bitmap 등은 큰 트리에서 메모리 사용량 증가 가능
  - Seal 모델은 런타임 동적 갱신이 필요한 시나리오에 부적합
- 안정성
  - 테스트/벤치마크/프로퍼티 테스트/퍼즈 테스트 부재
  - 문서/예제/가이드 부재로 오용 가능성 증가
- DX
  - 파라미터 결과가 (offset, length)만 제공 → 문자열/타입 추출 유틸 부족
  - `u16` route key만 반환 → 사용자 매핑 보일러플레이트 증가
  - 옵션/동작에 대한 문서/경고/로그 가이드 부족

## 8) 개선 제안(우선순위 로드맵: key-only 엔진 관점)
1. 안정성/기본 품질
  - 최소 단위 테스트: 등록/조회(정적/파라미터/와일드카드) + 경로 정규화 실패 케이스
  - 벤치 스켈레톤 추가(criterion) 및 샘플 라우트 집합 성능 측정
  - 퍼즈/프로퍼티 테스트로 경계값 검증(긴 세그먼트, 비정상 입력)
2. DX 보강(핵심 스코프 유지)
  - 파라미터 추출 헬퍼(문자열 슬라이스 변환/iterator 제공) — 순수 유틸, 엔진 순수성 유지
  - 문서/예제/README/quickstart — key-only 사용 패턴 가이드
3. 기능 확장(선택적, 스코프 준수)
  - 옵션 세분화: ASCII 강제/퍼센트 디코딩 선택, trailing slash 정책(키 매칭에 영향을 주는 범위 내)
  - 패턴 확장: 세그먼트 제약(숫자 등), 옵셔널 세그먼트, 명명된 catch-all(여전히 키 반환)
4. 성능·메모리 튜닝
  - Static map 활성화 히ュー리스틱/상한치 노출 및 문서화
  - 패턴 인덱스 고도화(세그먼트 길이 버킷, 문자열 인덱스)
  - Seal 이후 옵션 유지 보장(다음 등록 라운드에서도 동일 옵션 상속)
5. 운영 관점
  - `tracing` 필드 일관성/레벨 가이드, 에러 코드 매핑 문서화
  - panic-free API 보장 확인(모든 경로 Result 반환)

## 9) 기능 체크리스트(요약)
- [x] 라딕스 트리 기반 빠른 매칭
- [x] 네임드 파라미터 `:name`
- [x] 와일드카드(마지막 세그먼트)
- [x] 정적 경로 O(1) 매핑(옵션)
- [x] ReadOnly 스냅샷, 락 없는 조회
- [x] Bulk insert 최적화
- [ ] 제약/정규식/옵셔널/반복
- [ ] 그룹/Prefix/Host/버전
- [ ] 역방향 라우팅
- [ ] 핸들러/미들웨어 결합 API
- [ ] 트레일링 슬래시/대소문/퍼센트 디코딩 정책 노출
- [ ] 공식 벤치/테스트/문서

---
본 비교는 코드베이스(2025-10-14 시점)와 공용 문서를 바탕으로 한 정성적 분석입니다. 성능 수치는 벤치마크 추가 후 업데이트하는 것을 권장합니다.